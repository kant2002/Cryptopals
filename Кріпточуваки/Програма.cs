// ========================== рішення =====================================

// Виклик1();
// Виклик2();
Виклик3();

void Виклик3()
{
    байт[] ціль = ПереконвертуватиХекс("1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736");
    var (найкращаМаска, декодованіДані) = ЗнайтиМаскуВиключногоАбо(ціль);

    Консоль.НадрукуватиЛінію($"Найкраща маска {найкращаМаска}");
    Консоль.НадрукуватиЛінію(ДоРядка(декодованіДані));
}

void Виклик2()
{
    байт[] ціль = ПереконвертуватиХекс("1c0111001f010100061a024b53535009181c");
    байт[] маска = ПереконвертуватиХекс("686974207468652062756c6c277320657965");
    байт[] замаскованіДані = ВиключенеАбо(ціль, маска);
    Консоль.НадрукуватиЛінію(ДоХекс(замаскованіДані));
}

void Виклик1()
{
    байт[] вхідніДані = ПереконвертуватиХекс("49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d");
    рядок декодованіДані = ЗакодуватиДоБази64(вхідніДані);
    Консоль.НадрукуватиЛінію(декодованіДані);
}

// ========================== вспоміжні функції =====================================
(байт Маска, байт[] ДекодованіДані) ЗнайтиМаскуВиключногоАбо(байт[] дані)
{
    байт найкращаМаска = 0;
    ціл найкращійРахунок = 0;
    байт[] декодованіДані = Масив.Пустий<байт>();
    for (ціл маска = 0; маска <= 255; маска++)
    {
        байт[] замаскованіДані = ВиключенеАбоМаска(дані, (байт)маска);
        ціл рахунок = КількістьПробілів(замаскованіДані);
        if (рахунок > найкращійРахунок)
        {
            найкращаМаска = (байт)маска;
            найкращійРахунок = рахунок;
            декодованіДані = замаскованіДані;
        }
    }

    return (найкращаМаска, декодованіДані);
}

ціл КількістьПробілів(байт[] дані)
{
    ціл результат = 0;
    for (var і = 0; і < дані.Length; і++)
    {
        if (дані[і] == (byte)' ')
        {
            результат++;
        }
    }

    return результат;
}

байт[] ВиключенеАбо(байт[] ціль, байт[] маска)
{
    Відладка.Вдостовіритися(ціль.Length == маска.Length);

    байт[] результат = new байт[ціль.Length];
    for (var і = 0; і < ціль.Length; і++)
    {
        результат[і] = (байт)(ціль[і] ^ маска[і]);
    }

    return результат;
}

байт[] ВиключенеАбоМаска(байт[] ціль, байт маска)
{
    байт[] результат = new байт[ціль.Length];
    for (var і = 0; і < ціль.Length; і++)
    {
        результат[і] = (байт)(ціль[і] ^ маска);
    }

    return результат;
}

байт[] ПереконвертуватиХекс(рядок хекс)
{
    Список<байт> результат = new();
    for (ціл i = 0; i < хекс.Length; i += 2)
    {
        байт нижній = ХексЗначення(хекс[i + 1]);
        байт верхній = ХексЗначення(хекс[i]);
        результат.Додати((байт)(нижній + (верхній << 4)));
    }

    return результат.ДоМасиву();
}

рядок ДоХекс(байт[] дані)
{
    БудіникРядків результат = new();
    for (ціл і = 0; і < дані.Length; і += 1)
    {
        результат.Додати(дані[і].ToString("x2"));
    }

    return результат.ДоРядка();
}

рядок ДоРядка(байт[] дані)
{
    БудіникРядків результат = new();
    for (ціл і = 0; і < дані.Length; і += 1)
    {
        результат.Додати((char)дані[і]);
    }

    return результат.ДоРядка();
}

байт ХексЗначення(симв символ) => символ switch
{
    >= '0' and <= '9' => (байт)(символ - '0'),
    >= 'a' and <= 'f' => (байт)(символ - 'a' + 10),
    >= 'A' and <= 'F' => (байт)(символ - 'A' + 10),
    _ => throw new Виключення($"Не хекс символ {символ}")
};

рядок ЗакодуватиДоБази64(байт[] дані)
{
    БудіникРядків результат = new();
    for (ціл i = 0; i < дані.Length; i+=3)
    {
        ціл sum = дані[i+2] + (дані[i + 1] << 8) + (дані[i] << 16);
        симв w = ВзятиПоБазі64(sum & 0x3F);
        симв x = ВзятиПоБазі64((sum >> 6) & 0x3F);
        симв y = ВзятиПоБазі64((sum >> 12) & 0x3F);
        симв z = ВзятиПоБазі64((sum >> 18) & 0x3F);
        результат.Додати(z);
        результат.Додати(y);
        результат.Додати(x);
        результат.Додати(w);
    }

    return результат.ДоРядка();
}

симв ВзятиПоБазі64(ціл значення) => значення switch
{
    >= 0 and <= 25 => (симв)(значення + (байт)'A'),
    >= 26 and <= 51 => (симв)(значення - 26 + (байт)'a'),
    >= 52 and <= 61 => (симв)(значення - 52 + (байт)'0'),
    62 => '+',
    63 => '/',
    _ => throw new Виключення($"Значення {значення} виходить за межи діапазону бази 64")
};

байт[] ДекодуватиПоБазі64(string input)
{
    Список<байт> результат = new();
    for (ціл i = 0; i < input.Length; i+=4)
    {
        ціл w = input[i];
        ціл x = input[i+1];
        ціл y = input[i+2];
        ціл z = input[i+3];

        ціл sum = w + x << 6 + y << 12 + z << 18;

        результат.Додати((байт)(sum & 0xFF));
        результат.Додати((байт)(sum >> 8 & 0xFF));
        результат.Додати((байт)(sum >> 16 & 0xFF));
    }

    return результат.ДоМасиву();
}
